# 9.3. SYMPER RTM

| Info       | Value            |
| ---------- | ---------------- |
| Writer     | Datdt            |
| Start date | 2021-12-02       |
| End date   | 2021-12-01       |
| Type       | Internal network |

To understand the meaning of dataflow, please click on the following link: [Dataflow](https://app.gitbook.com/s/-McNyP8y\_A8MZOZl5QPQ/business-intelligence/untitled-2)

![Dataflow RTM](<../.gitbook/assets/image (30).png>)

With input data as documents as shown in the image, respectively requirement, sprint, test case and bug tracking

Use node "load" ![](<../.gitbook/assets/image (109) (1).png>) to load the input data. Then select the fields to display and filter in the right sidebar as shown in the image

![Right sidebar of the load node](<../.gitbook/assets/image (35).png>)

Next, filter the records where the [requirement ](8.2.-symper-requirement.md)id is empty. Use node filter and append output from Requirement to that filter like image ![](<../.gitbook/assets/image (71) (1).png>) The results corresponding to the filter will be returned below when click RUN ![](<../.gitbook/assets/image (74) (1) (1).png>) button

Next, left join ![](<../.gitbook/assets/image (26).png>) the [requirement](8.2.-symper-requirement.md) document with the [sprint ](8.7.-sprint.md)document to filter out the requirements that are scheduled for processing. Knowing the precise plan of requirements and which department members are in charge of it is the next step.

![Left join Requirement with Sprint](<../.gitbook/assets/image (99) (1) (1) (1).png>)

From the data available above (Requirements id, description, related members,...), continue to left join them with the test case to see if those requirements are tested

![Left join with Test case](<../.gitbook/assets/image (13) (1) (1).png>)

We continue to left join with the above input data with [issue tracking ](8.6-issue-tracking.md)to know is a problem in the test case or not? It generates the report in a proper format that includes the number of test cases executed, the number of failed test cases, and the test cases that have been skipped

![Left join with ISSUE TRACKING](<../.gitbook/assets/image (24) (1).png>)

We have compiled the number of issues based on requirements, sprints and test cases. Next is to count the number of bugs based on the state (DONE, NEW, TOTAL BUG)

![Count Bug](<../.gitbook/assets/image (47).png>)

Next, use node Summarize ![](<../.gitbook/assets/image (72) (1).png>) to aggregate and count the requirement IDs according to the parent requirements

![](<../.gitbook/assets/image (21) (1).png>)

To aggregate according to the parent requirement, select count for tb1\_id so that the result is the total number of child requirements

![Count Requirement Child](<../.gitbook/assets/image (36).png>)

Same for counting test cases based on requirements to ensure test coverage (Test coverage monitors the number of tests that have been executed)

![Count Test case](<../.gitbook/assets/image (96).png>)

Finally, we have information about the number of requirements, the number of test cases and the number of bugs by state, we fully join them together as shown in the picture.

![Full join](<../.gitbook/assets/image (78) (1).png>)


